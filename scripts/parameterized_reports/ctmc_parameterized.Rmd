---
title: "snapper CTDS"
author: "David"
date: "3/15/2021"
output: html_document
params: 
  resolution: 10
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F)
```

Import libraries
```{r}
library(here)
library(raster)
library(sf)
library(tidyverse)
library(mgcv)
library(ctmcmove)
library(rgdal)
library(glue)
library(broom)
library(dotwhisker)
```

Read in data
```{r}
reefclass <- raster(here("data/Seabed Maps/geotiff/", "ChickenRock_Classification.tif"))
df<-read_csv(here("data/red.snapper.locations.csv"))
current_resolution<-params$resolution
```

Raster values:
- sand == 1
- low == 2
- medium == 3
- high == 4  

Resize landcover data using parameter value. Take the most common values (the mode) from the original 1m cells to assign larger cells.
```{r}
ras<-aggregate(reefclass, fact=params$resolution, fun=modal)
```


Pull off coordinate reference system from landcover raster and transform snapper GPS data to match
```{r}
# pull off coordinate reference system from land cover raster layer
crs_ras<-crs(ras)

# convert snapper points to spatial object
df<-df %>% st_as_sf(coords = c("lon", "lat"), crs = 4326)

# transform points to crs of raster
df<-st_transform(df, crs=crs_ras)

# double check
st_crs(df)==st_crs(ras)
```

Create a raster layer for the intercept in the eventual GLM model
```{r}
int<-ras
values(int)<-1

stack_rast<-stack(int, ras)
names(stack_rast)<-cbind(c("int", names(ras)))
```

Pull off coordinates from snapper gps layer to use later. 
(Converting to spatial sf object 'sucks up' the coordinate columns from the dataframe)
```{r}
df<-df %>% 
  mutate(x=st_coordinates(.)[,1],
         y=st_coordinates(.)[,2])
```

Drop points that fall outside the extent of the landcover raster
```{r}
df$ras_value<-raster::extract(ras, df)
df<-df %>% drop_na(ras_value)
```

A little more housekeeping
```{r}
df<-df %>% arrange(num, datetime)
df<-df %>% rename(id=num) # one transmitter used on two fish, so num is the unique ID for each fish
```

Only use 3 fish for comparative purposes
```{r}
df<-df %>% 
  filter(id==9|id==12|id==16)
```



Process data for CTMC
```{r process data for ctmc}
ids<-as_factor(unique(df$id))
snapper_list<-list()

for(i in seq_along(ids)){
  tmp<-df %>% filter(id==ids[[i]])
  
  ## turn time into a numeric value (in days since Jan 1, 1970)
  t<-as.numeric(strptime(tmp$datetime, format="%Y-%m-%d %H:%M:%S"))/60/60/24
  
  ## get xy values for each time point
  xy<-tmp %>% dplyr::select(x,y)
  
  snapper_list[[i]]<-data.frame(t=t, x=xy$x, y=xy$y)
}
```

Convert from discrete-time continuous-space to continuous-time discrete space using landcover grid.
```{r dtcs to ctds}
n_snap<-length(snapper_list)
ctmc_list<-list()

for(i in 1:n_snap){
  ctmc_list[[i]]<-path2ctmc(xy = snapper_list[[i]][,-1], 
                            t = as.numeric(snapper_list[[i]][,1]),
                            method="LinearInterp",
                            rast = stack_rast
                            )}
```

Convert CTMC path into poisson glm data
```{r ctmc to poisson data}
glm_list<-list()

for(i in 1:n_snap){
  glm_list[[i]]<-ctmc2glm(ctmc_list[[i]], 
                          stack.static = stack_rast,
                          stack.grad = ras)
}
  
str(glm_list[[1]])
```

Add individual snapper id
```{r add each snapper id to list}
n.list <- length(ctmc_list)

for(i in 1:n.list){
  glm_list[[i]]$id <- rep(as.numeric(unique(df$id)[i]), times = length(glm_list[[i]]$z))
}
```

Convert from list to dataframe
```{r list to dataframe}
snap_dat<-glm_list[[1]]  
for(i in 2:n_snap){
  snap_dat<-rbind(snap_dat, glm_list[[i]])
}  
```

Check for instantaneous and very small transitions and remove them.
```{r remove very small transitions}
zeros<-length(which(snap_dat$tau==0))
cat(paste0("There were ", zeros, " transitions with zero time"))

teensies<-length(which(snap_dat$tau<10^-5))
cat(paste0("There were ", teensies, " transitions with tau less than 0.0001 seconds"))

snap_dat<-snap_dat %>% filter(tau>10^-5)
```

I removed tau's under 10^-5 because that is what Hanks et al and Brennan et al use.  
We probably want to think this over though.  

Make sure habitat data is categorical for GLM
```{r}
snap_dat<-snap_dat %>% rename(habitat=ChickenRock_Classification)
snap_dat$habitat<-as.factor(snap_dat$habitat)
```

Save out data for later use
```{r}
tmp_file<-glue("glm_ready_3fish_{current_resolution}_m^2_res.Rdata")
if(!tmp_file%in%here("processed_data")){
 saveRDS(snap_dat, file=here("processed_data", tmp_file))}
```


Fit GLM
```{r fit glm}
m1<-glm(z~habitat+crw,
        offset=log(tau),
        family=poisson,
        data=snap_dat)
```

Summarize output
```{r}
summary(m1)
```

Also fit models for each ID
```{r}
by_snap <- snap_dat %>%
    group_by(id) %>%                        # group data by transmission
    do(tidy(glm(z~habitat+crw, offset=log(tau), family=poisson, data=.))) %>%         # run model on each group
    ungroup() %>% rename(model = id)
```

Plot the coefficients
```{r}
snap_plot <- small_multiple(by_snap) +
  theme_bw() + ylab("Coefficient Estimate") +
  geom_hline(yintercept = 0, colour = "grey60", linetype = 2) +
  ggtitle("CTMC GLM") +
  theme(plot.title = element_text(face = "bold"), 
        legend.position = "none",
        axis.text.x = element_text(angle = 60, hjust = 1)) + xlab("Snapper ID")

snap_plot
```


Function used to render html (run in console)
```{r}
render_report<-function(resolution){
  rmarkdown::render(
    here::here("scripts/parameterized_reports/ctmc_parameterized.Rmd"), params=list(
      resolution=resolution
    ),
    output_file = paste0("CTMC grouped summary for ", resolution, " m^2 grid cell size.html")
    )
}
```














